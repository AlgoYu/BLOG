---
title: JVM运行原理之运行时数据区
id: JVM-RuntimeDataArea
directory: Guide
tags:
  - JVM
  - Java虚拟机
cover: https://static.runoob.com/images/mix/code-wallpaper-22.jpg
date: 2018-11-03 11:10:31
---
> JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。
Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。

今天来为大家一步一步解析JVM的运行原理，在我们编译源代码.java文件时，Java编译器会生成具有相同文件名的.class文件（包含字节码）。当我们运行.class文件时，这些.class文件会进入各个步骤，这些步骤描述了整个JVM的工作内容,网上已经有详细的图解，示例三张：
![](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/jvm-3.jpg)
![](https://javatutorial.net/wp-content/uploads/2017/10/jvm-architecture.png)
![](https://www.javainterviewpoint.com/java-virtual-machine-architecture-in-java/jvm-architecture/)
## **运行时数据区(Runtime Data Area)** ##
运行时数据区主要分为五个内容：

> 1. 方法区域
2. 堆区域
3. 堆栈区域
4. PC寄存器
5. 本地方法堆栈区域

## 方法区域：##
> **所有类级别数据都将存储在此处，包括静态变量。每个JVM只有一个方法区域，它是一个共享资源。**
通常，方法区域是堆区域的逻辑部分。但这需要由JVM实施者来决定。  方法区域具有每个类的结构和字段。只有静态的场和结构。它还包括方法数据，方法和构造函数代码，运行时常量池。方法区域在JVM启动时创建，并在所有线程之间共享。如果在运行时分配的内存区域不足，JVM将抛出OutOfMemoryError。
对于JVM的方法区，可能听得最多的是另外一个说法——**永久代（Permanent Generation）**，呼应堆的新生代和老年代。方法区和堆的划分是JVM规范的定义，而不同虚拟机有不同实现，对于Hotspot虚拟机来说，将方法区纳入GC管理范围，这样就不必单独管理方法区的内存，所以就有了”永久代“这么一说。方法区和操作系统进程的正文段（Text Segment）的作用非常类似，它存储的是已被虚拟机加载的类信息、常量（从JDK1.7开始已经移至堆内存中）、静态变量等数据。现设置JVM参数为”-XX:MaxPermSize=20M”（方法区最大内存为20M）。
**永久代从JDK1.8中已经被废弃，移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。由于永久代内存经常不够用或发生内存泄露，抛出异常java.lang.OutOfMemoryError: PermGen**
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小： 
　　-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。 
　　-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。 
　　除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性： 
　　-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 
　　-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集 

## 堆区域：##
> **所有对象及其对应的实例变量和数组将存储在此处。每个JVM只有一个堆区域。由于Method和Heap区域共享多个线程的内存，因此存储的数据不是线程安全的。**
堆数据区用于存储类和数组的对象。堆内存很常见，可以跨多个线程共享。这是垃圾收集器出现的地方。如年轻的Gen，PermGen。在VM启动时创建堆数据区域。通过垃圾收集器（GC）自动完成对内存的声明。这是Java的最佳功能之一。如果在运行时分配的内存不足，JVM可能会抛出OutOfMemoryError。

## 堆栈区域：##
> **对于每个线程，将创建单独的运行时堆栈。对于每个方法调用，将在堆栈存储器中创建一个条目，称为堆栈帧。将在堆栈内存中创建所有局部变量。堆栈区域是线程安全的，因为它不是共享资源。堆栈框架分为三个子实体：**
在堆栈帧中包括**局部变量表(Local Variables)**、**操作数栈(Operand Stack)**、指向当前方法所属的类的运行时常量池的**引用(Reference to runtime constant pool)**、**方法返回地址(Return Address)**和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。讲到这里，大家就应该会明白为什么 在 使用 递归方法的时候容易导致栈内存溢出的现象了以及为什么栈区的空间不用程序员去管理了（当然在Java中，程序员基本不用关系到内存分配和释放的事情，因为Java有自己的垃圾回收机制），这部分空间的分配和释放都是由系统自动实施的。对于所有的程序设计语言来说，栈这部分空间对程序员来说是不透明的。
> **1. 局部变量数组**-与方法有关，涉及多少局部变量，相应的值将存储在此处。
**2. 操作数堆栈**-如果需要执行任何中间操作，则操作数堆栈充当运行时工作空间以执行操作。
**3. 帧数据**-对应于该方法的所有符号都存储在此处。在任何异常的情况下，捕获块信息将保留在帧数据中。

## PC寄存器：##
> **每个线程都有独立的PC寄存器，用来保存当前正在执行的指令的地址，一旦指令被执行，PC寄存器将被下一条指令更新。**
在一般的计算机架构术语中，程序计数器(PC)寄存器随时记录执行的当前指令。这就像一个指向程序中指令序列的当前指令的指针。Java JVM术语也是如此。我们有多线程架构，因为Java支持多线程，所以每次创建一个新线程时都会创建一个程序计数器(PC)寄存器。PC保持一个指向当前正在其线程中执行的语句的指针。如果当前执行的方法是“本机”，那么程序计数器寄存器的值将不被定义。

## 本地方法堆栈区域：##
> **本机方法堆栈保存本机方法信息。对于每个线程，都将创建一个独立的本机方法堆栈。**
支持本机方法的JVM将具有本机方法堆栈。它用于本机方法，并按线程创建。如果JVM无法加载本机方法，则它不需要本机方法堆栈。内存大小的管理类似于固定或动态的一般JVM堆栈。JVM将相应地抛出StackOverflowError或OutOfMemoryError。

<b><font color="FF0000">文章全部信息均为本人手写，禁止任何转载，本人QQ：794763733。</font></b>