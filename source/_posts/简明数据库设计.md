---
title: 简明数据库设计
id: DatabaseDesign
directory: Guide
tags:
  - DBA
  - 数据库
  - 数据库管理员
  - Database Administrator
  - 数据库设计
cover: https://static.runoob.com/images/mix/maxresdefault.jpg
date: 2018-11-15 14:19:52
---
> ## 什么是数据库设计？ ##
数据库设计(Database Design)就是根据业务系统的具体需求，结合我们所选用的DBMS（Database Management System），为这个业务系统构造出最优的数据存储模型。并建立好数据库中的表结构及表与表之间的关联关系的过程。使之能有效的对应用程序中的数据进行存储，并可以高效的对已经存储的数据进行访问。

**优秀的数据库设计：**

> - 减少数据冗余
- 避免数据维护异常
- 节约存储空间
- 高效的访问

**糟糕的数据库设计：**

> - 存在大量的数据冗余
- 存在数据插入、更新、删除异常
- 浪费大量的存储空间
- 访问数据低效

## **数据库设计的步骤：** ##

> 1. 需求分析
2. 逻辑设计
3. 物理设计
4. 维护优化

以上步骤是非常重要的，很多项目刚刚开始的时候数据库设计是比较完美的，但是后来随着业务的不断增加，表结构越来越复杂，很多的步骤就忽略不计了，导致数据维护越来越困难，下面让我们来开始一步一步的讲解设计步骤。


----------

## **第一步：需求分析** ##
需求分析这一步是非常重要的，很多人往往会忽略这一点，例如：我们的数据库中存储的数据有些具有时效性，而有些并不具有时效性，对于一些具有时效性的数据，我们可以采取过期清理，或者归档的方式来进行存储。还有一些数据增长很快，数据量也很大，但是这些数据并不是我们的核心数据，对这些数据我们也可以采取分表，分库的方式进行存储。

> 1. 了解系统中所要存储的数据
2. 了解数据的存储特点
3. 了解数据的声明周期

**要搞清楚的问题：**

> 我们要搞清楚在数据库中存储的对象有些什么，这些对象可以称之为实体。有时候大家会觉得困惑，实体跟数据库表之间的关系究竟是什么？实际上，有时候一个实体对应数据库中的一张表，也有时候一个实体也会对应数据库中的多张表，同样，一张表也可以对应多个实体。所以，实体和数据库表之间的关系，并不是一一对应的。

**需求分析内容：**

> 1. 实体与实体之间的关系（1-to-1，1-to-N，N-to-M）
2. 实体的属性有什么？
3. 实体的哪些属性可以唯一标识一个实体
4. 实体的增长量
5. 实体的存储特性

**举例：用户模块**

> - **实体作用：**用于记录注册用户信息
- **包括属性：**用户账号、用户密码、用户电话号码、用户邮箱、用户身份证号码、用户地址、用户姓名、用户昵称……
- **可选的唯一标识属性：**用户账号、用户身份证号码、用户电话号码
- **增长量：**随着系统上线时间增加
- **存储特性：**永久存储

**举例：商品模块**

> - **实体作用：**用于记录网站中销售的商品信息
- **包括属性：**商品编码、商品名称、商品描述、商品品类、供应商名称、商品重量、商品有效期、商品价格……
- **可选的唯一标识属性：**商品编码、（商品名称、供应商名称）
- **增长量：**随着系统上线时间增加
- **存储特性：**对于下线商品可以归档存储

**举例：订单模块**

> - **实体作用：**用于用户订购商品的信息
- **包括属性：**订单编号、用户姓名、用户电话、用户地址、商品编号、商品名称、商品数量、商品价格、订单状态、支付状态、订单类型……
- **可选的唯一标识属性：**订单编号
- **增长量：**随着系统上线时间增加
- **存储特性：**永久存储（分表、分库）

**举例：购物车模块**

> - **实体作用：**用于保存用户购物时暂存的商品
- **包括属性：**用户账号、商品编号、商品名称、商品价格、商品描述、商品品类、加入时间、商品数量……
- **可选的唯一标识属性：**购物车编号
- **增长量：**随着系统上线时间增加
- **存储特性：**不用永久存储（设置归档，清理规则）

……
**分析它们之间的“关系”：**

>- **用户与购物车的关系：** 1-to-1
- **用户与订单的关系：** 1-to-N
- **订单与商品的关系：** N-to-M
- ……

## **第二步：逻辑设计** ##
逻辑设计就是将我们需求分析中所得到的我们这个应用中所要存储的数据类型来建立数据库的逻辑模型这个过程，我们不必考虑我们所选择的数据库管理系统所具有的特性，逻辑模型在任何数据库管理系统中都应该是通用的。流程如下：

> 1. 将需求转化为数据库的逻辑模型
2. 通过ER图的形式对逻辑模型进行展示
3. 同所选用的具体的DBMS系统无关

**名词解释：**

> - **关系：**一个关系对应通常所说的一张表
- **元组：**表中的一行即为一个元组
- **属性：**表中的一列即为一个属性；每个属性都有一个名称，成为属性名
- **候选码：**表中的某个属性组，它可以唯一确定一个元组
- **主码：**一个关系有多个候选码，选定其中一个为主码
- **域：**属性的取值范围
- **分量：**元组中的一个属性值

**ER图例说明：**

> - **矩形：**表示实体集；矩形内写实体集的名字
- **菱形：**表示联系集
- **椭圆：**表示实体集的属性
- **线段：**将属性连接到实体集，或将实体集连接到联系集

像这样的ER图网上实在太多了，可以从网上自行获取。
**举例ER图：**
![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1542283644949&di=fca1d143a1b3a737bcd5f34e942aac05&imgtype=0&src=http%3A%2F%2Ftxt22263.book118.com%2F2017%2F0516%2Fbook107143%2F107142635.jpg)


> **设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。目前好像说有六种范式，但是通常我们满足三大范式就足够了。**

> **1. 第一范式（1NF）**：所谓第一范式（1NF）是指在关系模型中，对于添加的一个规范要求，所有的域都应该是原子性的，即数据库表的**每一列都是不可分割的原子数据项**，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。**<font color="FF0000">（所有字段值都是不可分解的原子值，不能是集合，数组。简而言之，第一范式就是无重复的域。并且表结构不能是不规范的数据表样式，因为也根本无法创建。）</font>**
**2. 第二范式（2NF）：**在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。例如在员工表中的身份证号码即可实现每个一员工的区分，该身份证号码即为候选键，任何一个候选键都可以被选作主键。在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证号进行存储，而姓名可能会在数据库运行的某个时间重复，无法区分出实体时，设计辟如ID等不重复的编号以实现区分，被添加的编号或ID选作主键。（该主键的添加是在ER设计时添加，不是建库时随意添加）**要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性**，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。**<font color="FF0000">（数据库表中的每个实例或记录必须可以被唯一地区分，必须要有一个唯一标识，如果出现了属性并不与主键相关，那应该再分离出来一个实体。）</font>**
**3. 第三范式（3NF）：**在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。**<font color="FF0000">（每一列数据都和主键直接相关，而不能间接相关。要求一个表中不包含已在其它表已包含的非主关键字信息，我们可以通过外键来关联它们。）</font>**

## **第三步：物理设计** ##

> 根据特定数据库管理系统所提供的多种存储结构和存取方法等依赖于具体计算机结构的各项物理设计措施，对具体的应用任务选定最合适的物理存储结构(包括文件类型、索引结构和数据的存放次序与位逻辑等)、存取方法和存取路径等。这一步设计的结果就是所谓“物理数据库”。

**物理设计步骤：**

> 1. 选择合适的数据库管理系统
2. 定义数据库、表及字段的命名规范
3. 根据所选的DBMS系统选择合适的字段类型
4. 反范式化设计

**选择一款合适的DBMS系统：**

>常见的DBMS就是Oracle、SQL Server、MySQL、PgSQL等，而Oracle、SQL Server呢是商业数据库，如果选择商业数据库的话，成本是必须要考虑的一个方面，而MySQL、PgSQL是开源数据库，开源数据库是完全免费的，只要遵从使用协议，就不会被收取任何的版权费用。大部分时候，商业数据库更适合企业级项目，而开源数据库则适用于互联网项目。
>
 - **Oracle：**是目前业内口碑最好的数据库系统，当然价格也非常昂贵，适合比较大的事物操作，读写速度也非常快。
 - **SQL Server：**是微软开发的数据库系统，也是商业数据库，适合中小型企业。只能运行在Windows环境下，如果和.Net开发语言进行搭配是比较好的。
 - **MySQL：**使用最广泛的数据库，是开源免费的，在WEB应用方面 MySQL 是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。
 - **PgSQL:**号称世界上最先进的开源关系数据库系统，有很多非常先进的概念，性能非常稳定，但是知名度不高。

**选择合适的存储引擎：**

> 如果我们选择MySQL数据库系统，我们就得选择一个合适的存储引擎。因为MySQL是开源的，所以它的存储相对来说也是非常开放的。只要符合MySQL的存储协议，任何厂商都可以开发自己的存储引擎。大部分情况下我们使用InnoDB，它支持事物，而且支持多版本并发控制的行级锁。

| 存储引擎 | 事物 | 锁粒度 | 主要应用 | 忌用 |
| :------: | :------: | :------: | :------: | :------: |
| MyISAM | 不支持 | 支持并发插入的表级锁 | INSERT,SELECT | 频繁的读写操作 |
| MRG_MYISAM | 不支持 | 支持并发插入的表级锁 | 分段归档、数据库仓库 | 全局查找过多的场景 |
| InnoDB | 支持 | 支持MVCC的行级锁 | 事物隔离处理 | 无 |
| Archive | 不支持 | 支持行级锁 | 日志记录，只支持INSERT,SELECT | 需要随机读取、更新、删除操作的场景。 |
| Ndb cluster | 支持 | 支持行级锁 | 高可用性 | 大部分应用 |

**表及表字段的命名规则：**

> **1. 可读性原则：**使用大写和小写来格式化的库对象名字以获得良好的可读性。（注意：有些DBMS系统对表名的大小写是敏感的）
 **2. 表意性原则：**对象的名字应该能描述它所表示的对象，表的名称应该能够体现表中存储的数据内容，存储过程名称应该能够体现存储过程的功能。
 **3. 长名原则：**尽可能少使用或者不适用缩写，因为缩写在很多时候会有歧义，适用于数据库（DATABASE）名之外的任一对象。
 
 **字段类型的选择原则：**
> 列的数据类型一方面影响数据存储空间的开销，另一方面也会影响数据查询性能，当一个列可以选择多种数据类型的时候，应该优先考虑数值类型，其次是日期时间和二进制类型，最后才是字符类型。对于相同级别的数据类型，应该选择占用空间小的数据类型。

Birthday(生日)字段举例：
| 数据类型 | 值 |
| :------: | :------: |
| CHAR(10) | '1997-08-01' |
| VARCHAR(10) | '1997-08-01' |
| DATETIME(10) | 1997-08-01 |
| INT | 870364800 |
>对于生日字段，我们应该优先选择数值类型，使用INT数据类型存储时间戳，方便我们排序、比较，因为在进行数据比较时，相同的数据，字符处理会比数字处理慢很多，它需要参考字符字典。而数值类型不需要，所以速度上也要高于字符类型；其次再考虑日期时间和二进制数据类型，在同级的字符类型上CHAR和VARCHAR，对于时间这种长度变化不大的数据，我们应该优先选择占用字节数较少的CHAR，在数据库中，数据处理以页为单位，列的长度越小，利于性能的提升；反之如果数据的长度是可变的，则应该选择VARCHAR。

**数据库设计其他注意事项：**

> **1. 区分业务主键和数据库主键：**业务主键用于标识业务数据，进行表与表之间的关联；数据库主键为了优化数据存储（InnoDB会生成6个字节的隐含主键）。
 **2. 根据数据库的类型，考虑主键师傅需要顺序增长：**有些数据库是按主键的顺序逻辑存储的。
 **3. 主键的字段类型所占用空间要尽可能的小：**对于使用聚集索引方式存储的表，每个索引后都会附加主键信息。
 **4. 避免使用外键约束：**外键的主要作用是为了保证数据的完整性，但是在实际开发的项目中，对高并发要求我们使用外键的话，会带来很多的负面影响。如果我们使用了外键，对于数据的写入，每次写入都会查询是否符合外键约束，如果符合才允许写入，比较耗时，而且增加了很多的维护成本。虽然不建议使用外键约束，但是相关联的列上一定要建立索引。
 **5. 避免使用触发器：**我们经常使用触发器来减少程序逻辑处理，比如在操作某张表的时候，我们使用触发器来记录日志，降低了数据写入的效率，有时候会出现意想不到的数据异常，如果业务变更，或者开发人员变更，触发器使得我们的业务逻辑变得更加复杂。
 **6. 严禁使用预留字段：**我们无法知道预留字段的数据类型和存储的内容，维护预留字段和创建新的字段成本是相同的。
 
 **反范式化设计：**

> 反范式化是针对范式化而言的，在前面介绍过数据库设计的三种范式，所谓的反范式化设计就是为了性能和读取速度的考虑，适当的对第三范式的要求进行违反，允许存在少量的数据冗余，有时候一张表中可以适当的增加一些其他表中的字段，减少表关联，降低SQL语句的复杂度，来增加查询速度，提高效率。换句话来说就是使用空间来换取时间。

## **第四步：维护优化** ##

> 在数据库系统正式投入运行的过程中，必须不断地对其进行调整与修改。至今，数据库设计的很多工作仍需要人工来做，除了关系型数据库已有一套较完整的数据范式理论可用来部分地指导数据库设计之外，尚缺乏一套完善的数据库设计理论、方法和工具，以实现数据库设计的自动化或交互式的半自动化设计。所以数据库设计今后的研究发展方向是研究数据库设计理论，寻求能够更有效地表达语义关系的数据模型，为各阶段的设计提供自动或半自动的设计工具和集成化的开发环境，使数据库的设计更加工程化、更加规范化和更加方便易行，使得在数据库的设计中充分体现软件工程的先进思想和方法。

**维护和优化中要做些什么？**

> 1. 维护数据字典
2. 维护索引
3. 维护表结构 
4. 在适当的时候对表进行水平拆分或者垂直拆分

**维护数据字典：**

> 现在维护数据字典有很多种方式，可以使用第三方工具对数据字典进行维护，可以针对数据库系统来选择第三方工具，或者可以使用数据库本身的备注字段来维护字典（COMMENT），可以通过查询导出数据字典。

**维护索引：**

> **如何选择合适的列建立索引？**
索引是一个非常大的话题，我们只是简单的聊一下，在选择上，我们可以考虑选择在WHERE、GOURP BY、ORDER BY从句中出现的列来建立索引，索引中的列不要包括太长的数据类型，我们要选择可选性高的列要放在索引的前面。这个时候大家可能会有一个误区，在索引列的顺序上要跟WHERE常见中的列的顺序要保持一致。实际上这个要求并不是必须的，因为在现在的数据库中，所有的SQL语句在执行之前都要经过SQL优化器重新编译，在编译过程中，SQL优化器就会按照我们数据库中的索引还有统计信息对查询列进行重新的排序和优化。
**索引是不是越多越好？**
索引并不是越多越好，反而过多的索引会降低我们的读写效率。如果我们建立了大量的索引，每写入一条记录，都要对这些索引进行维护，重建一些索引统计信息，大大的降低了写的效率。而且在我们查询的时候，SQL优化器会根据我们的索引信息和统计信息，来选择适合我们SQL所适合的索引，如果对于一个SQL来说有太多的可以适用的索引的话，SQL优化器会在多种适用这个SQL的索引中进行选择，选择的过程就会降低我们查询的效率。
**定期维护索引碎片**
由于我们对表中的数据不断的进行更新、删除、插入的操作，会产生分页（具体请自行百度），同时产生索引碎片，如果一个页中出现大量的索引碎片，我们一个页中所记录的信息也会相对的减少，因此我们需要定期的清理。
**在SQL语句中不要使用强制索引关键字**
首先，由于我们数据量的不断变化，在原来适用的索引，在数据量增加过后可能就不太合适了，这个时候如果我们使用的是强制索引关键字，不但会影响数据库的效率，如果DBA一旦把这个索引进行更名或者删除。这条SQL语句就会直接报错。

**维护表结构：**

> 维护表结构的工作就是，表中的列增加、删除，或者更改列数据类型。对表结构更改后请及时的维护数据字典，控制好表的宽度和大小，正如之前所说，很多项目刚上线的时候，表结构是非常完美的。但由于需求越来越多，业务逻辑越来越复杂，就不再注重设计细节了。

**数据中适合的操作：**

> - **批量操作 VS 逐条操作：** （数据库更适合批量操作，逐条适合在程序中完成。）
- **禁止使用 SELECT *：**（浪费I/O查询大量不必要的数据。）
- **控制使用用户自定义函数：**（索引不起作用，自定义函数往往非常低效。）
- **不要使用数据库中的全文索引：**（需要建立索引文件来进行维护，对中文的支持并不好）

**表的水平拆分或者垂直拆分：**

> - **水平拆分：**如果我们希望原来一张数据量很多的表数据量减少，就需要对它进行水平拆分，我们希望每张表中只存一定量的数据，就是说把原来的一张表复制了多份，表结构也是完全一样的，我们可以通过主键Hash Key的方式平均的把数据分到很多张相同的表中，每张表的数据量是非常平均且数据都不相同。这就是水平拆分。
- **垂直拆分：**实际上就是把原来的一张表分成多张小的表，在我们的需求越来越多，我们一直往一张表增加列，当这张表的宽度已经有几十列的时候，我们就要考虑对它进行垂直拆分了。因为我们数据库是以页来进行存储的，一张表中的列非常多的时候，每页存储的数据也就相对来说比较大，我们的I/O效率就会变得很低，我们可以把一些数据大的字段拆分到另一张表中，记住拆分前和拆分后，表的数据量不应该会有变化。

<b><font color="FF0000">文章内容均为本人手写；<br>禁止转载，请尊重原著；<br>本人QQ：794763733。</font></b>